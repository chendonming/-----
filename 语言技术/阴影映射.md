# 阴影映射

## 第一步 光即相机

在图形学中，为了知道哪些地方被挡住了（在阴影里），我们需要先模拟光源在看什么。

对于**平行光（Directional Light）**，因为它的光线是平行的，所以我们必须使用 **正交相机（OrthographicCamera）** 来模拟它。

所以我们的目标是:

创建一个代表光源的相机，并把画面渲染出来。我们要确保通过这个相机，能完整地看到场景里的物体。

```js
// 假设光源在 (5, 10, 5) 的位置
const lightPosition = new THREE.Vector3(5, 10, 5);

// 创建正交相机来模拟平行光
// 参数分别代表：左、右、上、下边界，近裁面、远裁面
// 这里的范围 (-5 到 5) 决定了阴影能覆盖多大的区域
const shadowCamera = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 50);

// 把相机移到光源位置，并让它看着原点(0,0,0)
shadowCamera.position.copy(lightPosition);
shadowCamera.lookAt(0, 0, 0);
```

## 第二步 保存深度

第二步的目标： 将第一步中“光看到的画面”保存下来，但不是保存颜色，而是保存**深度（Depth）**。这就是所谓的 **Shadow Map（阴影贴图）**。

此步骤具体有两个操作:

-   创建一个**“离屏画布”（WebGLRenderTarget）**，把光看到的画面画到这里，而不是画到屏幕上。
-   创建一个专用的**“深度材质”**，不管物体原本是什么颜色，强制把它们的颜色变成*它们离相机的距离（深度）*。

```js
// 1. 创建离屏渲染目标 (Shadow Map)
// 我们把它设为 1024x1024 分辨率
const shadowTarget = new THREE.WebGLRenderTarget(1024, 1024);

// 2. 创建深度材质 (用于生成深度图的 shader)
// 这个 Shader 的作用：把当前像素的深度值 (0.0~1.0) 写入到颜色里
const depthMaterial = new THREE.ShaderMaterial({
    vertexShader: `
        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        void main() {
            // gl_FragCoord.z 是当前片元的深度值 (0.0 到 1.0)
            // 我们把它存到 RGB 通道里，画出来就是黑白图
            gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
        }
    `,
});
```

## 第三步 读取比较

第三步的目标： 编写主场景的 Shader，读取这张深度图，并算出投影坐标。

这是整个阴影映射最难理解的数学部分。

在 Pass 2（主相机渲染）中，对于场景中的任意一个点（例如地板上的某个像素），我们要回答：_“这个点，在刚才那张小黑白图里的坐标 (u, v) 是多少？”_

只要找到了这个 (u, v)，我们就能查到那张图上记录的深度值。

这个变换过程如下：

-   World Position (世界坐标)
-   乘以 Light View Matrix (光源看世界) -> 变到光源正前方
-   乘以 Light Projection Matrix (光源透视) -> 变到裁剪空间 [-1, 1]
-   乘以 Texture Matrix (0.5 偏移) -> 变到纹理空间 [0, 1]

```js
// 1. 创建用于传给 Shader 的矩阵
const uShadowMatrix = new THREE.Matrix4();

// 2. 创建主材质
const mainMaterial = new THREE.ShaderMaterial({
    uniforms: {
        uColor: {value: new THREE.Color(0x00aaff)},
        uShadowMap: {value: shadowTarget.texture}, // 传入刚才生成的纹理
        uShadowMatrix: {value: uShadowMatrix}, // 传入变换矩阵
    },
    vertexShader: `
        varying vec4 vShadowCoord; // 传给片元
        uniform mat4 uShadowMatrix;
        uniform mat4 modelMatrix;

        void main() {
            // 1. 算出世界坐标
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            
            // 2. 核心魔法：算出该点在 ShadowMap 上的坐标
            vShadowCoord = uShadowMatrix * worldPos;

            // 3. 常规操作
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D uShadowMap;
        uniform vec3 uColor;
        varying vec4 vShadowCoord;

        void main() {
            // 将坐标归一化 (虽然正交投影 w=1，但这步是标准流程)
            vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;

            // --- 调试可视化 ---
            // 我们不直接画阴影，而是把计算出来的投影坐标画出来看看
            // 如果计算正确，物体表面应该会像贴了一张幻灯片一样，
            // 显示出从光源视角看到的画面。
            
            // 如果坐标在纹理范围内，就显示纹理颜色
            if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 &&
                shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {
                
                // 读取 ShadowMap 的颜色
                vec4 depthColor = texture2D(uShadowMap, shadowCoord.xy);
                
                // 把深度图贴在物体表面上！
                gl_FragColor = depthColor; 
            } else {
                // 超出光照范围显示红色
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        }
    `,
});
```

矩阵的逻辑:

```js
const textureMatrix = new THREE.Matrix4();
// [-1, 1]压缩到[0,1]
textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);

uShadowMatrix.identity();
uShadowMatrix.multiply(textureMatrix); // 3. 缩放偏移到 0~1
uShadowMatrix.multiply(shadowCamera.projectionMatrix); // 2. 投影变换
uShadowMatrix.multiply(shadowCamera.matrixWorldInverse); // 1. 视图变换 (World -> Camera)
```

## 最后: 比较大小

```js
// ... (其他代码保持不变) ...

// 修改主材质的 Fragment Shader
const mainMaterial = new THREE.ShaderMaterial({
    uniforms: {
        uColor: {value: new THREE.Color(0x00aaff)},
        uShadowMap: {value: shadowTarget.texture},
        uShadowMatrix: {value: uShadowMatrix},
        uLightPos: {value: lightPos}, // 传入光源位置算漫反射
    },
    vertexShader: `
        varying vec3 vNormal;
        varying vec4 vShadowCoord; 
        uniform mat4 uShadowMatrix;
        uniform mat4 modelMatrix;

        void main() {
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            vShadowCoord = uShadowMatrix * worldPos;
            
            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D uShadowMap;
        uniform vec3 uColor;
        uniform vec3 uLightPos;
        varying vec4 vShadowCoord;
        varying vec3 vNormal;

        void main() {
            // 1. 拿到查找坐标 (NDC -> UV)
            vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;

            // 初始假设：不在阴影里，shadow = 1.0 (全亮)
            float shadow = 1.0;

            // 2. 只有当坐标在纹理范围内才进行判断
            if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 &&
                shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {
                
                // 【关键理解 A】：从图中读出最近距离
                float closestDepth = texture2D(uShadowMap, shadowCoord.xy).r;
                
                // 【关键理解 B】：算出当前距离
                float currentDepth = shadowCoord.z;

                // 3. 核心比较
                // Bias (0.005) 是为了解决精度误差导致的“阴影痤疮”(Shadow Acne)
                if (currentDepth > closestDepth + 0.005) {
                    // 如果 我比最近的物体还远，说明我被挡住了
                    shadow = 0.5; // 变暗，不要变成 0.0，否则是死黑
                }
            }

            // --- 下面是简单的光照计算，让画面好看点 ---
            
            // 漫反射 (Lambert)
            vec3 lightDir = normalize(uLightPos);
            float diff = max(dot(vNormal, lightDir), 0.0);
            
            // 最终颜色 = 材质颜色 * (环境光 + 漫反射 * 阴影因子)
            // 当 shadow 为 0.5 时，漫反射贡献减半，形成阴影
            vec3 finalColor = uColor * (0.2 + diff * shadow);
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    `,
});
```
