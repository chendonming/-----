# 阴影映射

## 第一阶段：核心理论（阴影是即视感）

Shadow Mapping 的核心思想很简单：**如果你是光源，你能看到的地方就是亮的；你看不到的地方，就是阴影。**

这个过程分为两个**Pass（渲染通道）**：

1.  **Pass 1（深度通道 / 阴影通道）：**
    *   把摄像机移动到光源的位置。
    *   渲染场景，但不关心颜色，只记录**每个像素离光源有多远（深度值 Z）**。
    *   把这个结果存到一张纹理上，这张图叫 **Shadow Map（深度图）**。

2.  **Pass 2（渲染通道 / 主相机通道）：**
    *   把摄像机移回原来的位置（玩家视角）。
    *   正常渲染场景中的每个像素。
    *   对于每个像素，问一个问题：**“这个像素的位置，比 Shadow Map 上记录的最近距离还要远吗？”**
        *   如果 **更远**：说明有东西挡在它和光源之间 -> **阴影**。
        *   如果 **一样近**：说明它就是离光源最近的物体 -> **照亮**。

---

## 第二阶段：准备工作（搭建基础设施）

我们需要手动创建“光源视角”的相机和用于存储深度的纹理。

### 1. 创建“光之眼” (Shadow Camera)
既然我们模拟平行光，就用正交相机（OrthographicCamera），因为平行光的投影线是平行的。

```javascript
// 模拟光源位置
const lightPosition = new THREE.Vector3(10, 20, 10);

// 创建光源视角的相机
const shadowCamera = new THREE.OrthographicCamera(-10, 10, 10, -10, 0.5, 50);
shadowCamera.position.copy(lightPosition);
shadowCamera.lookAt(0, 0, 0);
shadowCamera.updateMatrixWorld(); // 确保矩阵更新
```

### 2. 创建 Shadow Map (Render Target)
这相当于一块“离屏画布”，我们不画到屏幕上，而是画到这里面存储深度。

```javascript
const shadowMapSize = 1024;
const shadowTarget = new THREE.WebGLRenderTarget(shadowMapSize, shadowMapSize, {
    minFilter: THREE.NearestFilter, // 也就是不做平滑，为了学习原理看硬边缘
    magFilter: THREE.NearestFilter,
    format: THREE.RGBAFormat 
    // 注意：在纯原生WebGL中只需存深度分量，但在Threejs简单实现中，我们存RGBA即可
});
```

### 3. 创建深度材质 (Depth Material)
在 Pass 1 中，我们需要把所有物体染成“深度色”。Three.js 提供了 `MeshDepthMaterial`，我们直接用它来生成深度图。

```javascript
const depthMaterial = new THREE.MeshDepthMaterial();
// 修正：MeshDepthMaterial 默认是基于相机 Near/Far 的非线性深度，
// 为了配合正交相机手动计算，我们这里先用 Three.js 的通用行为，
// 后面Shader里我们会通过手动矩阵计算深度，这里主要为了占位渲染。
```

---

## 第三阶段：核心难点 —— 投影矩阵的数学推导

这是最容易让人晕的地方。我们需要在 Pass 2 的 Shader 中，算出当前像素在 Pass 1 的 Shadow Map 里的坐标 (u, v)。

路径是：
`顶点世界坐标` -> `光源相机空间` -> `光源裁剪空间(-1 到 1)` -> `纹理空间(0 到 1)`

我们需要构造一个 **MVP 矩阵**，但针对的是光源。

```javascript
// 创建一个辅助矩阵，用于将坐标从 [-1, 1] 映射到 [0, 1]
// 因为 NDC 坐标系原点在中心，范围 -1~1
// 而 UV 坐标系原点在左下角，范围 0~1
// 公式: uv = ndc * 0.5 + 0.5
const textureMatrix = new THREE.Matrix4();
textureMatrix.set(
    0.5, 0.0, 0.0, 0.5,
    0.0, 0.5, 0.0, 0.5,
    0.0, 0.0, 0.5, 0.5,
    0.0, 0.0, 0.0, 1.0
);

// 真正的 ShadowMatrix = textureMatrix * lightProj * lightView
// 这个矩阵会在渲染循环中实时计算并传入 Shader
```

---

## 第四阶段：编写 Shader (手动实现阴影逻辑)

这是你的学习重点。

### 1. Vertex Shader (顶点着色器)
我们需要计算两个位置：
1. `gl_Position`：主相机看到的屏幕位置（用于画出来）。
2. `vShadowCoord`：该顶点在“光源视角屏幕”上的位置（用于查深度）。

```glsl
varying vec3 vNormal;
varying vec4 vShadowCoord; // 传递给片元着色器

// 我们将手动传入这个矩阵
uniform mat4 uShadowMatrix; 
uniform mat4 modelMatrix; // Three.js 自动提供，但有时手动声明更清晰

void main() {
    // 1. 标准的世界坐标
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    
    // 2. 关键：计算该顶点在 ShadowMap 纹理上的对应坐标
    // uShadowMatrix 包含了：World -> LightView -> LightProj -> UV变换
    vShadowCoord = uShadowMatrix * worldPosition;
    
    // 3. 标准渲染流程
    vNormal = normalize(normalMatrix * normal);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
```

### 2. Fragment Shader (片元着色器)
这里进行比较逻辑。

```glsl
uniform sampler2D uShadowMap; // 我们生成的深度图
uniform vec3 uColor;
varying vec3 vNormal;
varying vec4 vShadowCoord;

void main() {
    // --- 阴影计算核心 ---
    
    // 1. 透视除法 (Perspective Divide)
    // 将齐次坐标 (xyzw) 转换为标准化设备坐标 (xyz)
    // 对于正交相机 w 通常是 1，但为了严谨（适配透视光）必须除以 w
    vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;
    
    float shadow = 1.0; // 默认是亮处

    // 只有当坐标在 [0,1] 范围内才计算，否则在 ShadowMap 外面
    if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && 
        shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {
        
        // 2. 从 ShadowMap 中读取光源看到的深度值 (Blocker Depth)
        // 注意：因为我们用 MeshDepthMaterial 生成的纹理，
        // 读取到的颜色值 RGBA 需要被解码，或者如果配置得当直接就是深度。
        // 为了简化教学，我们假设 MeshDepthMaterial 写入了 r 通道深度。
        // (在实际工程中，depth packing 是个大学问，这里我们用简单的 unpack)
        float depthFromMap = texture2D(uShadowMap, shadowCoord.xy).r;
        
        // 3. 当前像素距离光源的深度 (Receiver Depth)
        float currentDepth = shadowCoord.z;
        
        // 4. 比较：Bias (偏移量) 非常重要！
        // 它可以消除 "Shadow Acne" (因为浮点数精度导致的波纹)
        float bias = 0.005; 
        
        // 如果当前深度 > 地图记录的深度 + bias，说明被挡住了
        // 还要注意 WebGL 中深度通常是 0(近) ~ 1(远)，也可能相反，取决于设置
        // Three.js MeshDepthMaterial 默认通常是 1(近) -> 0(远) 或者标准 GL 0->1
        // *但在我们手动矩阵下，z 是线性的 NDC z，我们需要确认方向。*
        // *为了教学最简化，我们使用 Threejs 的打包深度读取逻辑。*
        
        // 这里做一个最原始的硬比较：
        if (currentDepth > depthFromMap + bias) {
            shadow = 0.5; // 在阴影里，变暗
        }
    }

    // --- 简单的光照 ---
    vec3 lightDir = normalize(vec3(10, 20, 10)); // 和 JS 中保持一致
    float diff = max(dot(vNormal, lightDir), 0.0);
    
    vec3 finalColor = uColor * (0.2 + diff * shadow); // 环境光 + 漫反射*阴影
    
    gl_FragColor = vec4(finalColor, 1.0);
}
```

---

## 第五阶段：完整代码实现 (Copy & Run)

为了让上面的理论跑通，我们需要处理一些 Three.js 特有的深度打包问题。Three.js 的 `MeshDepthMaterial` 默认把深度打包成 RGBA 编码。为了不引入复杂的解码算法，我们这里做一个**极其简化**的处理：

我们不用 `MeshDepthMaterial`，我们在 Pass 1 也用一个自定义的简单 Shader，把 `gl_FragCoord.z` 写入颜色。这样最直观。

```html
<!DOCTYPE html>
<html>
<head>
    <title>Manual Shadow Mapping Tutorial</title>
    <style>body { margin: 0; overflow: hidden; }</style>
</head>
<body>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
</script>
<script type="module">
import * as THREE from 'three';

// --- 场景初始化 ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 5, 8);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- 1. 定义光源 (逻辑上的) ---
const lightPos = new THREE.Vector3(5, 10, 5);
const shadowCamera = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 50);
shadowCamera.position.copy(lightPos);
shadowCamera.lookAt(0, 0, 0);
shadowCamera.updateMatrixWorld(); // 重要：更新矩阵

// 可视化光源位置（可选）
const helper = new THREE.CameraHelper(shadowCamera);
scene.add(helper);

// --- 2. 准备 Shadow Map (Pass 1 的目标) ---
const shadowTarget = new THREE.WebGLRenderTarget(1024, 1024, {
    minFilter: THREE.NearestFilter,
    magFilter: THREE.NearestFilter,
    format: THREE.RGBAFormat
});

// --- 3. Pass 1: 深度写入材质 ---
// 这个 Shader 只做一件事：把当前像素的深度值写入 RGBA 颜色的 R 通道
const depthShader = new THREE.ShaderMaterial({
    vertexShader: `
        void main() {
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        void main() {
            // gl_FragCoord.z 包含当前片元的深度 (0.0 到 1.0)
            gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 1.0);
        }
    `
});

// --- 4. Pass 2: 阴影渲染材质 ---
const shadowMatrix = new THREE.Matrix4(); // 用于 JS 更新

const mainShader = new THREE.ShaderMaterial({
    uniforms: {
        uColor: { value: new THREE.Color(0x00aaff) },
        uShadowMap: { value: shadowTarget.texture },
        uShadowMatrix: { value: shadowMatrix },
        uLightPos: { value: lightPos }
    },
    vertexShader: `
        varying vec3 vNormal;
        varying vec4 vShadowCoord; // 传给片元
        uniform mat4 uShadowMatrix;
        uniform mat4 modelMatrix;

        void main() {
            vec4 worldPos = modelMatrix * vec4(position, 1.0);
            
            // 核心计算：世界坐标 -> 纹理坐标
            vShadowCoord = uShadowMatrix * worldPos;

            vNormal = normalize(normalMatrix * normal);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D uShadowMap;
        uniform vec3 uColor;
        uniform vec3 uLightPos;
        varying vec3 vNormal;
        varying vec4 vShadowCoord;

        void main() {
            vec3 shadowCoord = vShadowCoord.xyz / vShadowCoord.w;
            
            // 默认全亮
            float shadow = 1.0;
            
            // 简单的边界检查，防止采样到纹理外
            if (shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 &&
                shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0) {
                
                // 1. 读取深度图中的值 (Blocker Z)
                // 我们在 depthShader 里把 z 存进了 R 通道
                float depthFromMap = texture2D(uShadowMap, shadowCoord.xy).r;
                
                // 2. 当前片元的深度 (Receiver Z)
                // 注意：由于我们自己在 Pass1 用了 gl_FragCoord.z，它是非线性的 Screen Space Z
                // 而这里的 shadowCoord.z 也是经过同样的投影变换得到的，所以可以直接比
                float currentDepth = shadowCoord.z;
                
                // 3. 比较 + Bias
                // Bias 越大，阴影越不容易产生波纹，但可能产生 "Peter Panning" (阴影悬空)
                float bias = 0.003; 
                
                if (currentDepth > depthFromMap + bias) {
                    shadow = 0.5; // 阴影浓度
                }
            }

            // 基础漫反射
            vec3 lightDir = normalize(uLightPos);
            float diff = max(dot(vNormal, lightDir), 0.0);
            
            // 最终颜色
            gl_FragColor = vec4(uColor * (0.2 + diff * shadow), 1.0);
        }
    `
});

// --- 创建物体 ---
const geometry = new THREE.BoxGeometry(1, 1, 1);
const cube = new THREE.Mesh(geometry, mainShader);
cube.position.y = 1;
scene.add(cube);

const plane = new THREE.Mesh(new THREE.PlaneGeometry(10, 10), mainShader);
plane.rotation.x = -Math.PI / 2;
scene.add(plane);

// --- 渲染循环 ---
function animate() {
    requestAnimationFrame(animate);
    
    // 让方块动起来
    cube.rotation.y += 0.01;
    cube.rotation.x += 0.01;

    // --- STEP 1: 更新 Shadow Matrix ---
    // 顺序：Model(在shader里乘) -> View(light) -> Proj(light) -> TextureMatrix
    
    const textureMatrix = new THREE.Matrix4().set(
        0.5, 0.0, 0.0, 0.5,
        0.0, 0.5, 0.0, 0.5,
        0.0, 0.0, 0.5, 0.5,
        0.0, 0.0, 0.0, 1.0
    );
    
    shadowCamera.updateMatrixWorld();
    shadowCamera.updateProjectionMatrix();
    
    // shadowMatrix = textureMatrix * lightProj * lightViewInverse
    shadowMatrix.identity();
    shadowMatrix.multiply(textureMatrix);
    shadowMatrix.multiply(shadowCamera.projectionMatrix);
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    
    // --- STEP 2: 渲染 Shadow Map (Pass 1) ---
    // 我们利用 scene.overrideMaterial 强行把所有物体换成 depthShader 渲染一遍
    scene.overrideMaterial = depthShader;
    
    renderer.setRenderTarget(shadowTarget);
    renderer.setClearColor(0xffffff, 1.0); // 清除为最远深度(1.0)
    renderer.render(scene, shadowCamera); // 注意这里用的是 shadowCamera!
    renderer.setRenderTarget(null); // 切回屏幕
    
    scene.overrideMaterial = null; // 取消覆盖，用回原来的 mainShader

    // --- STEP 3: 渲染主场景 (Pass 2) ---
    renderer.render(scene, camera);
}
animate();

</script>
</body>
</html>
```

## 学习要点总结

1.  **光即相机**：阴影贴图本质上就是从光源视角拍摄的一张照片，只不过照片里存的是深度而不是颜色。
2.  **坐标变换链**：`uShadowMatrix` 是连接两个世界的桥梁。它把“玩家世界里的点”强行拉到了“光源屏幕上的点”。
3.  **Override Material**：在 Pass 1 中，我们不需要物体原本的颜色，只需要几何形状。Three.js 的 `scene.overrideMaterial` 是个极其好用的技巧，它能临时替换场景中所有物体的材质。
4.  **Bias (偏移)**：你在代码中会看到 `bias = 0.003`。你可以试着把它改成 0，你会看到物体表面出现难看的条纹（Shadow Acne）。这是因为深度图的分辨率有限，导致采样精度不够，自我遮挡产生的误差。
5.  **硬阴影**：这个实现产生的是锯齿状的“硬阴影”。如果要实现软阴影（PCF），你就需要在 Fragment Shader 里，不只采一个点，而是采样周围的 4 个或 9 个点，取平均值。

这就是通过原生 Shader 实现阴影映射的最底层原理！希望这能帮你打开图形学的大门。