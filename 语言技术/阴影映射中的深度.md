# 阴影映射中的深度

## 手动计算 gl_FragCoord.z

为了明白**gl_FragCoord.z**是怎么来的,现在手动来计算这个值.

Vertex Shader (顶点着色器):

```c
varying vec4 vPos; // 定义一个 varying 变量传给片元

void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    vPos = gl_Position; // 将裁剪空间坐标传出去
}
```

Fragment Shader (片元着色器):

```c
varying vec4 vPos;

void main() {
    // 1. 透视除法：将裁剪空间转为 NDC (-1.0 到 1.0)
    float ndcZ = vPos.z / vPos.w;

    // 2. 映射区间：将 NDC (-1.0 ~ 1.0) 映射到 深度区间 (0.0 ~ 1.0)
    float depth = ndcZ * 0.5 + 0.5;

    gl_FragColor = vec4(vec3(depth), 1.0);
}
```

## 空间转换

gl_Position 处于 **裁剪空间 (Clip Space)。**

`gl_FragCoord` 处于 **窗口空间 (Window Coordinates)**，也可以叫**屏幕空间 (Screen Space)。**

我们来看一下数据是如何从顶点着色器一步步变成 `gl_FragCoord` 的:

### 坐标变换流水线

显卡硬件在顶点着色器和片元着色器之间，会自动做以下三步操作，这部分不需要你写代码，是 GPU 自动完成的:

#### 第一步：顶点着色器输出

你写了 `gl_Position = projectionMatrix * ...`。
此时坐标是 **裁剪空间 (Clip Space)**，格式为 $(x_c, y_c, z_c, w_c)$。

-   $w_c$ 通常等于相机空间的 $-z$（在透视投影中）。

#### 第二步：透视除法 (Perspective Division)

GPU 将 `gl_Position` 的 $x, y, z$ 分别除以 $w$。
此时坐标变为 **NDC (归一化设备坐标)**，格式为 $(x_n, y_n, z_n)$。

-   范围：$x, y, z$ 都在 $[-1.0, 1.0]$ 之间。
-   超出这个立方体的部分会被裁剪掉（这就是“裁剪空间”名字的由来）。

#### 第三步：视口变换 (Viewport Transformation)

这是最关键的一步，GPU 将 NDC 坐标映射到你的画布（Canvas）或渲染目标（RenderTarget）的尺寸上。
假设你的 Shadow Map 分辨率是 `1024 x 1024`：

-   **x (水平位置):** $[-1, 1]$ $\rightarrow$ $[0, 1024]$
-   **y (垂直位置):** $[-1, 1]$ $\rightarrow$ $[0, 1024]$
-   **z (深度值):** $[-1, 1]$ $\rightarrow$ $[0, 1]$ (通常是 $0$ 到 $1$)

**最终生成的结果就是 `gl_FragCoord`。**

## 详解 `gl_FragCoord` 的四个分量

在片元着色器中，`gl_FragCoord` 是一个 `vec4`，它的含义如下：

### `gl_FragCoord.x` 和 `gl_FragCoord.y`

这是当前片元（像素）在屏幕上的**绝对像素坐标**。

-   **原点 (0, 0)**：通常在**左下角**。
-   **单位**：像素 (Pixels)。
-   **中心点**：像素的中心通常是 `.5`，例如第 1 个像素的中心是 $(0.5, 0.5)$。
-   **用途**：如果你想做全屏滤镜、马赛克效果，或者根据屏幕位置改变颜色，会用到它。

### `gl_FragCoord.z` (重点)

这是当前片元的**深度值**。

-   **范围**：固定在 $[0.0, 1.0]$。
    -   $0.0$ 代表最近（Near Plane，近裁剪面）。
    -   $1.0$ 代表最远（Far Plane，远裁剪面）。
-   **计算公式**：
    $$ Z_{window} = \frac{Z_{ndc} + 1}{2} $$
    即：它就是把 NDC 的 $z$ 值 $(-1 \text{ 到 } 1)$ 线性映射到了 $(0 \text{ 到 } 1)$。
-   **用途**：
    1.  **深度测试 (Depth Test)**：GPU 会自动拿这个值跟深度缓冲区里的值对比，决定是否丢弃该像素。
    2.  **阴影映射**：正如你代码里写的，把这个值存下来，就是阴影图。

### `gl_FragCoord.w`

这是**透视修正系数**，实际上它是 $1.0 / gl\_Position.w$。

-   它主要用于纹理采样的透视矫正插值。一般在 Shader 逻辑中很少直接用到它，除非你在做非常底层的深度重建算法。
