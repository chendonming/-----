# 阴影映射中的深度精度

## 简单操作的隐患

```c
gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
```

普通的纹理通常是 UnsignedByte 类型的，意味着 R、G、B 每个通道只有 8 位 (0~255)。
如果你直接把深度存进 R 通道，深度的精度只有 1/256 ≈ 0.004。这会导致阴影产生严重的**马赫带 (Shadow Acne / Banding)**，看起来像阶梯一样。

## 原理

Three.js（以及很多传统的 WebGL/OpenGL 引擎）中所谓的“打包深度（Packing Depth）”，其核心原理就是**将一个高精度的 32 位浮点数（Float），拆解并存储到 RGBA 纹理的 4 个 8 位通道（Byte）中**。

### 1. 为什么要这么做？（背景与痛点）

*   **原始数据**：`gl_FragCoord.z` 是一个高精度浮点数（通常是 32 位），取值范围 0.0 ~ 1.0。
*   **存储容器**：在 WebGL 1.0 或为了最大的设备兼容性，我们通常使用 `UNSIGNED_BYTE` 类型的 RGBA 纹理作为 Shadow Map。
*   **限制**：在这种纹理中，R、G、B、A 每个通道只能存储 8 位数据，也就是 0 到 255 之间的整数。

**如果直接存：**
如果只用 R 通道存深度：`gl_FragColor = vec4(depth, 0, 0, 1)`。
精度 = $1 / 256 \approx 0.0039$。
这意味着，如果你的场景深度是 100 米，那么最小能区分的距离是 40 厘米。任何小于 40 厘米的起伏都会被抹平，导致阴影产生严重的**条纹（Acne）**。

**解决方案：**
利用 RGBA 4 个通道，总共 $8 \times 4 = 32$ 位，来近似存储这个 32 位的浮点数。这能让精度提高几百万倍。

---

### 2. 数学原理：类似于“进制转换”

你可以把这个过程想象成**将一个小数转换成 256 进制**。

举个十进制的例子：
假设有一个小数 `0.1234`，我们要把它存到 4 个只能存 1 位数（0-9）的格子里。
1.  **第1格**：存 `1` (代表 0.1)
2.  **第2格**：存 `2` (代表 0.02)
3.  **第3格**：存 `3` (代表 0.003)
4.  **第4格**：存 `4` (代表 0.0004)

**在 Shader 中的做法（256进制）：**

假设深度 `depth = 0.5`（二进制其实很复杂，这里为了理解简化）。
我们需要把 `depth` 分解为：
$$ \text{Depth} \approx \frac{R}{256^0} + \frac{G}{256^1} + \frac{B}{256^2} + \frac{A}{256^3} $$
*(注意：Shader里通常归一化了，所以是乘法，但逻辑一样)*

#### 具体的编码（Packing）算法

Three.js 内部使用的算法如下（简化版）：

1.  **位移（Shift）**：把深度值分别放大 1倍、256倍、65536倍...
    *   `res.x = depth * 1.0`
    *   `res.y = depth * 256.0`
    *   `res.z = depth * 256.0 * 256.0`
    *   `res.w = depth * 256.0 * 256.0 * 256.0`

2.  **取小数（Fract）**：我们只关心当前进制位的数据，去掉整数部分。
    *   `res = fract(res)`
    *   比如 `0.1234 * 10 = 1.234` -> `fract` -> `0.234`。这步保证每个通道只存 0.0~1.0 的值。

3.  **剔除高位影响（Subtract）**：这是最关键的一步。
    *   `res.y` 里面包含了 `res.x` 的信息。我们需要把高位通道在当前通道的贡献减掉。
    *   公式逻辑：`当前通道值 - (高位通道值 / 256)`。

**代码实现 (GLSL):**

```c
// 这就是 Three.js 中 <packing> chunk 里的 packDepthToRGBA 核心逻辑
vec4 packDepthToRGBA( const in float v ) {
    // 1. 定义位移向量：[1, 256, 65536, 16777216]
    const vec4 bitShift = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
    
    // 2. 定义掩码向量：[1/256, 1/256, 1/256, 0]
    const vec4 bitMask  = vec4( 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0, 0.0 );
    
    // 3. 计算每一位的值
    // 假设 v = 0.5 (在R通道)
    // res 此时包含所有低位的信息混合在一起
    vec4 res = fract( v * bitShift );
    
    // 4. 剔除高位
    // res.x (R通道) 是准确的
    // res.y (G通道) 包含了 R通道的小数部分，我们需要把 R通道对 G 的影响减去
    // res -= res.xxyz * bitMask 相当于：
    // G = G - R / 256
    // B = B - G / 256 ...
    res -= res.xxyz * bitMask;
    
    return res;
}
```

---

### 3. 解码原理（Unpacking）

当你读取 Shadow Map 时，你拿到的是一个 `vec4` 颜色。你需要把它还原回一个 float 深度。
原理就是**点积（Dot Product）**：将每个通道的值乘以其对应的权重，然后加起来。

$$ \text{Depth} = R \times 1 + G \times \frac{1}{256} + B \times \frac{1}{65536} + A \times \frac{1}{16777216} $$

**代码实现 (GLSL):**

```c
float unpackRGBAToDepth( const in vec4 v ) {
    const vec4 bitShift = vec4( 1.0, 1.0 / 256.0, 1.0 / ( 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 * 256.0 ) );
    return dot( v, bitShift );
}
```

### 4. 总结

Three.js 的“标准做法”其实是一个**由精度限制倒逼出来的编码技巧**。

*   **现状**：现代 WebGL 2.0 或者支持 `OES_texture_float` 扩展的环境，其实可以直接使用 **浮点纹理 (Float Texture)** 或 **深度纹理 (Depth Texture)**。
*   **浮点纹理**：直接存 float，不需要 Pack/Unpack，性能更好，精度完美。
*   **兼容性**：但在 WebGL 1.0 时代或低端移动端，浮点纹理支持不完善，`packDepthToRGBA` 是最安全、兼容性最好的方案，所以它成为了“标准做法”。

如果你现在的项目明确使用 WebGL 2，你可以直接创建一个格式为 `THREE.DepthTexture` 的渲染目标，那就完全不需要这段代码了，显卡会自动处理所有深度读写，既快又准。