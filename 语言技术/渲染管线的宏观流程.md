# 渲染管线的宏观流程

## 一、 宏观概览图

在进入细节之前，先看一个简化的流程图：

`顶点数据 -> 顶点着色器 -> 图元装配 -> 光栅化 -> 片元着色器 -> 逐片元操作 -> 帧缓冲区`

---

## 二、 详细流程解析

### 1. 准备阶段 (CPU / JavaScript)
在 GPU 开始工作之前，你需要通过 JavaScript 喂给它数据。
*   **创建缓冲区 (Buffers):** 你将顶点的坐标、颜色、纹理坐标（UV）、法线等数据存入 **VBO (Vertex Buffer Objects)**。
*   **状态设置:** 设置视口大小、开启深度测试、混合模式等。
*   **着色器编译:** 编译和链接顶点着色器与片元着色器，组成 **Program**。
*   **Draw Call (绘制指令):** 当你调用 `gl.drawArrays` 或 `gl.drawElements` 时，CPU 向 GPU 发送指令，**流水线正式启动**。

### 2. 顶点着色器 (Vertex Shader) —— “定位”
这是**可编程**阶段。GPU 会并行处理每一个顶点。
*   **输入:** 它是从 VBO 中拿到的单个顶点数据（Attributes），以及全局变量（Uniforms，如变换矩阵）。
*   **任务:**
    1.  **坐标变换:** 将顶点从 **模型空间 (Local)** -> **世界空间 (World)** -> **观察空间 (View)** -> **裁剪空间 (Clip Space)**。
    2.  这是最关键的一步，输出必须赋值给内置变量 `gl_Position`（裁剪空间坐标）。
*   **输出:** 变换后的顶点位置，以及需要传递给下一个阶段的数据（Varyings，如颜色、UV）。

> **工程师视点:** 此时顶点还在 3D 空间（准确说是 4D 齐次坐标），还没有变成像素。

### 3. 图元装配 (Primitive Assembly) —— “连线”
*   **任务:** 根据你绘制的模式（如 `gl.TRIANGLES`、`gl.LINES`），将上一步处理好的顶点组装成几何形状（通常是三角形）。
*   **裁剪 (Clipping):** 这一步非常重要。如果三角形的一部分在屏幕（视锥体）外面，GPU 会自动切掉多余的部分，甚至生成新的顶点来封口。
*   **透视除法:** 将裁剪坐标 `(x, y, z, w)` 转化为标准化设备坐标 (NDC) `(x/w, y/w, z/w)`，坐标范围变为 `[-1, 1]`。
*   **视口变换:** 将 NDC 坐标映射到屏幕像素坐标（比如 1920x1080）。

### 4. 光栅化 (Rasterization) —— “像素化”
这是图形学中最神奇的阶段，将**矢量图形转化为像素网格**。
*   **任务:** 计算出这个三角形覆盖了屏幕上的哪些像素。
*   **插值 (Interpolation):** 这是一个核心概念。顶点着色器输出的数据（比如颜色：顶点A是红色，顶点B是蓝色），在这一步会根据像素在三角形中的位置进行**线性插值**。中间的像素会自动变成渐变紫色。
*   **生成片元 (Fragment):** 每一个被三角形覆盖的像素候选者，被称为一个“片元”。

> **注意:** “片元”不等于“像素”。片元是**候选像素**，它带有颜色、深度（Z值）、纹理坐标等信息，但它最终不一定能显示在屏幕上（可能被遮挡）。

### 5. 片元着色器 (Fragment Shader) —— “上色”
这是**可编程**阶段。GPU 并行处理每一个片元。
*   **输入:** 光栅化阶段插值后的数据（Varyings）。
*   **任务:** 计算该像素最终应该显示什么颜色。
    *   **光照计算:** 使用法线和光照公式计算亮度。
    *   **纹理采样:** 根据 UV 坐标去纹理图片里找对应的颜色。
*   **输出:** 赋值给内置变量 `gl_FragColor` (RGBA 颜色)。

> **工程师视点:** 这个阶段通常是性能瓶颈所在，因为屏幕上有几百万个像素，复杂的算法在这里跑非常耗时。

### 6. 逐片元操作 (Per-Fragment Operations) —— “筛选与混合”
片元着色器计算出了颜色，但能不能画在画布上，还得过五关斩六将。
*   **裁剪测试 (Scissor Test):** 检查是否在裁剪矩形内。
*   **深度测试 (Depth Test):** **这是 3D 渲染的灵魂。** GPU 比较当前片元的深度值（Z值）和深度缓冲区（Depth Buffer）中已有的值。
    *   如果当前片元“更近”，则通过，并更新缓冲区。
    *   如果当前片元“被遮挡”，则**丢弃 (Discard)**，不进行绘制。
*   **模板测试 (Stencil Test):** 用于高级遮罩效果。
*   **混合 (Blending):** 如果物体是半透明的，不仅不能丢弃，还需要将当前片元的颜色与帧缓冲区中已有的颜色按比例混合（Alpha Blending）。

### 7. 写入帧缓冲区 (Frame Buffer)
*   通过了所有测试的片元，其颜色最终被写入颜色缓冲区（Color Buffer）。
*   浏览器将颜色缓冲区的内容显示在 `<canvas>` 上。

---

## 三、 总结：核心数据流向

为了方便记忆，我们可以追踪一下数据的变化：

1.  **Buffer (JavaScript):** 原始数据数组。
2.  **Attribute (Vertex Shader):** 具体的 3D 坐标点。
3.  **Varying (Rasterizer):** 经过插值的数据（平滑的过渡）。
4.  **Uniform (Global):** 对所有顶点/片元都一样的常量（如灯光位置、变换矩阵）。
5.  **Texture (Fragment Shader):** 图片皮肤。
6.  **Pixel (Screen):** 最终看到的图像。