# Vue3对比Vue2的升级

## 一、 响应式系统的重构 (核心原理层面)

这是 Vue 3 最本质的区别。

**1. 实现方式：Proxy vs Object.defineProperty**
*   **Vue 2 (Object.defineProperty):**
    *   **原理：** 初始化时递归遍历对象所有属性，进行 getter/setter 劫持。
    *   **痛点：**
        *   无法监听对象属性的**新增**和**删除**（需要 `Vue.set`/`Vue.delete`）。
        *   无法监听**数组**通过下标修改数组项的变化（需要重写数组方法）。
        *   初始化时必须递归遍历整个对象，如果数据结构嵌套很深，会有明显的性能损耗。
*   **Vue 3 (Proxy):**
    *   **原理：** 使用 ES6 的 `Proxy` 对整个对象进行代理。
    *   **优势：**
        *   可以直接监听对象属性的增删。
        *   可以直接监听数组的变化。
        *   **懒代理 (Lazy Observation)：** 只有当访问嵌套对象时，才会给该对象创建 Proxy，而不是一上来就递归到底，大大提升了初始化速度。

## 二、 代码组织与逻辑复用 (开发体验层面)

**1. Composition API (组合式 API) vs Options API (选项式 API)**
*   **Vue 2 (Options API):**
    *   **痛点：** 代码按 `data`, `methods`, `computed` 分类。当组件变大时，**同一个业务逻辑的代码分散在不同地方**（碎片化），上下反复横跳，维护困难。
    *   **复用难：** 主要靠 Mixins 复用逻辑，但 Mixins 存在命名冲突、来源不清晰的问题。
*   **Vue 3 (Composition API):**
    *   **优势：** 将同一个业务逻辑的代码（状态、方法、副作用）**聚合**在一起。
    *   **复用强：** 可以利用 "Composable" (组合式函数，类似 React Hooks) 完美提取逻辑，且没有 Mixins 的副作用。这是大型项目维护的关键。

## 三、 性能优化 (编译器与运行时层面)

Vue 3 在编译阶段做了很多“静态分析”的工作，让运行时跑得更快。

**1. 静态提升 (Static Hoisting)**
*   Vue 3 会检测模板中的静态节点（永远不会变的 HTML 标签），将它们的定义提升到渲染函数之外。
*   **结果：** 重新渲染时，这些静态节点直接复用，无需重新创建。

**2. 补丁标记 (Patch Flags)**
*   **Vue 2：** Diff 算法是全量比较。无论节点是动态还是静态，都要层层比对。
*   **Vue 3：** 编译时会在动态节点上打上“标记”（Patch Flag，比如 TEXT 表示只有文本变，CLASS 表示只有类名变）。
*   **结果：** Diff 算法只比对带有标记的动态节点，完全跳过静态节点，性能与动态内容的数量成正比，而不是与模板大小成正比。

**3. 事件监听缓存 (cacheHandlers)**
*   Vue 3 会缓存事件处理函数，避免每次渲染都重新创建函数实例，触发不必要的子组件更新。

## 四、 TypeScript 支持 (架构层面)

*   **Vue 2：** 是用 JavaScript 写的，对 TS 的支持是“后补”的（通过 d.ts 文件），在使用 Options API 时，`this` 的类型推断非常痛苦，体验较差。
*   **Vue 3：** 源码完全使用 **TypeScript 重写**。这意味着 Vue 3 原生具备极好的 TS 支持，配合 Composition API，类型推断非常顺滑，极大地提高了大型项目的可维护性。

## 五、 新特性与体积优化 (功能层面)

**1. Tree-shaking (按需打包)**
*   **Vue 2：** 很多 API（如 `Vue.nextTick`）是挂载在 Vue 全局对象上的，不管你用不用，打包时都会带上。
*   **Vue 3：** API 改为模块化导出（如 `import { nextTick } from 'vue'`）。如果你没用到某个功能，打包工具（Webpack/Vite）就会自动把这部分代码“摇掉”，显著减小 Bundle 体积。

**2. Fragment (碎片/多根节点)**
*   **Vue 2：** 组件模板必须有一个唯一的根节点。
*   **Vue 3：** 支持多个根节点，减少了不必要的 DOM 嵌套（Wrapper hell）。

**3. Teleport (传送门)**
*   允许将组件的 DOM 结构“传送”到 DOM 树的其他位置（如 `body` 底部），非常适合做模态框（Modal）、Toast 等组件，避免 `z-index` 层级问题。

**4. Suspense (实验性)**
*   原生支持处理异步组件加载状态（Loading/Error），无需在每个组件里手动写 `v-if="loading"`。

---

## 总结 ( Cheat Sheet )


> "Vue 3 相比 Vue 2 的提升主要体现在三个方面：**更快的性能、更好的逻辑组织、更完善的 TS 支持**。
>
> 1.  **在响应式系统上**：Vue 3 使用 `Proxy` 替代了 `Object.defineProperty`，解决了对象增删属性和数组下标无法监听的问题，并且实现了懒代理，初始化速度更快。
> 2.  **在编译优化上**：Vue 3 引入了 **Patch Flags（补丁标记）** 和 **静态提升**，使得 Diff 算法不再全量比较，只更新动态绑定的节点，大大减少了运行时的开销。
> 3.  **在开发体验上**：引入了 **Composition API**，解决了 Options API 在大型组件中逻辑碎片化的问题，让逻辑复用（Hooks）变得更加简单清晰，彻底替代了 Mixins。
> 4.  **在架构上**：源码全量使用 **TypeScript** 重写，提供了极佳的类型推断支持；同时支持 **Tree-shaking**，使得打包体积更小。"

**加分项：** 提到 Vue 3 对 Fragment 和 Teleport 的支持，以及 Vue 3 结合 Vite 工具链带来的开发热更新速度提升。