# MVP矩阵变换总览

## 坐标空间变换全景图

`局部空间 (Local)` $\xrightarrow{\text{Model Matrix}}$ `世界空间 (World)` $\xrightarrow{\text{View Matrix}}$ `观察空间 (View)` $\xrightarrow{\text{Projection Matrix}}$ `裁剪空间 (Clip)` $\xrightarrow{\text{透视除法}}$ `NDC (标准设备坐标)` $\xrightarrow{\text{视口变换}}$ `屏幕空间 (Screen)`

---

## 1. 局部空间 (Local Space / Object Space)
*   **这是什么？** 这是模型自己的地盘。比如美术在 Blender 里建了一个“茶壶”，茶壶的中心点通常是 `(0,0,0)`。无论你在游戏世界里把茶壶放在哪里，在这个空间里，它的顶点坐标永远相对于茶壶中心不变。
*   **当前状态：** 顶点只是相对于模型中心的原始数据。

## ⬇️ 变换 1：模型矩阵 (Model Matrix)
*   **作用：** 把模型“摆放”到世界里。
*   **包含操作：** 位移 (Translation)、旋转 (Rotation)、缩放 (Scale)。
*   **代码体现：** `M_Matrix`
*   **结果：** 顶点坐标变成了**世界坐标**。

---

## 2. 世界空间 (World Space)
*   **这是什么？** 这是你的整个游戏/应用场景。所有的物体（茶壶、桌子、灯光）都在这个统一的坐标系下找到了自己的绝对位置。
*   **当前状态：** 大家都在世界大地图的某个经纬度上。

## ⬇️ 变换 2：视图矩阵 (View Matrix)
*   **作用：** **把世界“搬”到摄像机面前。**
*   **关键概念：** 在图形学中，摄像机其实是不动的（通常默认在原点，看向 -Z 方向）。为了模拟摄像机移动，我们其实是在**反向移动整个世界**。
    *   *如果你想把摄像机向右移 5 米，实际上是把整个世界向左移 5 米。*
*   **代码体现：** `V_Matrix`（通常由 LookAt 函数生成）。
*   **结果：** 顶点坐标变成了**观察坐标**（相对于摄像机的坐标）。

---

## 3. 观察空间 (View Space / Camera Space)
*   **这是什么？** 以摄像机为中心的世界。摄像机在 `(0,0,0)`。
*   **重要性：** 在这里计算光照（有时候也在世界空间算）和 Z 值（距离摄像机多远）最直观。

## ⬇️ 变换 3：投影矩阵 (Projection Matrix)
*   **作用：** **创建视锥体（Frustum）并处理近大远小。**
*   **类型：**
    *   **透视投影 (Perspective):** 也就是平常人眼看到的 3D 效果，平行的铁轨在远处会相交。
    *   **正交投影 (Orthographic):** 无论远近物体一样大（用于工程制图或 UI）。
*   **代码体现：** `P_Matrix`
*   **结果：** 顶点进入了**裁剪空间**。这也是**顶点着色器 (Vertex Shader) 的终点**。

> **工程师划重点：** 在顶点着色器中，我们通常把这三步合并写成：
> `gl_Position = u_Projection * u_View * u_Model * a_Position;`
> 注意乘法顺序是从右向左（矩阵乘法特性：先应用 Model，再 View，最后 Projection）。

---

## 4. 裁剪空间 (Clip Space) —— ⚠️ 顶点着色器的输出 `gl_Position`
*   **这是什么？** 这是一个 4D 空间（齐次坐标 `x, y, z, w`）。
*   **特征：**
    *   在这个空间里，所有可见的几何体都必须位于一个特定的范围内。
    *   这里的 `w` 分量非常关键，它包含了深度的信息，用于下一步的除法。
*   **谁来做？** 这一步结束，你把 `gl_Position` 交给 GPU，接下来的步骤是 **GPU 自动完成的**（不可编程，但可配置）。

## ⬇️ 变换 4：透视除法 (Perspective Division)
*   **作用：** 将 4D 坐标转化为 3D 坐标。公式是 `(x/w, y/w, z/w)`。
*   **结果：** 也就是在这个瞬间，**“近大远小”** 真正发生了（因为远的物体 w 值大，除完之后 x 和 y 就变小了）。

---

## 5. NDC (Normalized Device Coordinates) —— 标准化设备坐标
*   **这是什么？** 一个边长为 2 的标准立方体。
*   **范围：** x, y, z 的值都在 `[-1, 1]` 之间。
*   **意义：** WebGL 不管你的屏幕是 800x600 还是 4K，也不管你的世界多大，最终它只认这个 `[-1, 1]` 的小盒子。超出这个盒子的部分被裁剪（切掉）。
*   **坐标系：** WebGL 中，NDC 是**左手坐标系**（Z轴朝向屏幕内为正，这与观察空间的右手系不同，是很多坑的来源）。

## ⬇️ 变换 5：视口变换 (Viewport Transform)
*   **作用：** 把 `[-1, 1]` 的数值映射到具体的像素坐标上。
*   **代码体现：** `gl.viewport(0, 0, canvas.width, canvas.height)`。
*   **计算：**
    *   $x_{screen} = \frac{x_{ndc} + 1}{2} \times width + x_{offset}$
    *   $y_{screen} = \frac{y_{ndc} + 1}{2} \times height + y_{offset}$

---

## 6. 屏幕空间 (Screen Space / Window Coordinates)
*   **这是什么？** 二维像素坐标（加上深度值 Z）。
*   **例子：** `(x: 960, y: 540, z: 0.5)`。
*   **后续：** 这个坐标被送去**光栅化**，生成片元。

---

## 总结对照表

| 空间名称 | 关键矩阵/操作 | 坐标维度 | 物理意义 |
| :--- | :--- | :--- | :--- |
| **Local Space** | 初始状态 | (x, y, z, 1) | 模型设计师眼中的样子 |
| *变换* | **Model Matrix** | | 摆放到场景中 |
| **World Space** | 中间状态 | (x, y, z, 1) | 绝对的世界坐标 |
| *变换* | **View Matrix** | | 移动世界以对齐摄像机 |
| **View Space** | 中间状态 | (x, y, z, 1) | 相对于摄像机的位置 |
| *变换* | **Projection Matrix** | | 定义可视范围、近大远小 |
| **Clip Space** | **Vertex Shader 输出** | (x, y, z, **w**) | 准备进行透视除法的 4D 坐标 |
| *变换* | **透视除法 (/w)** | | 硬件自动执行，归一化 |
| **NDC** | 中间状态 | (x, y, z) | **[-1, 1] 的立方体** |
| *变换* | **gl.viewport** | | 映射到画布尺寸 |
| **Screen Space** | 最终像素位置 | (x, y) + depth | 屏幕上的像素点 |