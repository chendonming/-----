# Vue3 快速 Diff 算法

## 核心总结

Vue 2 使用的是 `双端比较算法 (Double-ended Diff)`。

Vue 3 使用的是 `快速 Diff 算法 (Fast Diff)`，它借鉴了 `inferno` 算法，核心在于引入了 `最长递增子序列 (LIS)` 来**最大程度减少 DOM 移动操作**

## Vue3 快速 Diff 算法流程

### 第一步：预处理 (Sync Pre & Sync Post)

Vue 3 发现，在大多数实际开发中，开发者很少会完全打乱列表，通常只是头部或尾部发生变化。所以先处理头尾。

假设旧节点列表为 `A, B, C, D, E`，新节点列表为 `A, B, F, C, E`。

1.  **从头同步 (Sync from Start):**
    -   从左向右比对，发现 `A=A`, `B=B`。
    -   遇到 `C` 和 `F` 不同，停止。
    -   指针停在下标 2。
2.  **从尾同步 (Sync from End):**
    -   从右向左比对，发现 `E=E`。
    -   遇到 `D` 和 `C` 不同，停止。
3.  **结果：**
    -   掐头去尾后，剩下的就是“脏数据”区间：
    -   旧：`[C, D]`
    -   新：`[F, C]`

### 第二步：处理简单情况

如果预处理后：

-   **旧节点没了，新节点还有剩：** 说明是**新增**，直接把剩下的新节点挂载（Mount）。
-   **新节点没了，旧节点还有剩：** 说明是**删除**，直接把剩下的旧节点卸载（Unmount）。

### 第三步：处理复杂乱序 (核心难点)

如果掐头去尾后，新旧节点都有剩余（如上面的 `[C, D]` vs `[F, C]`），说明发生了**移动、修改、新增或删除**的混合情况。

**1. 构建新节点的映射表 (Key Map)**
Vue 3 会为**剩余的新节点**建立一个 `Key -> Index` 的 Map。

-   目的：为了快速查找旧节点在新列表中的位置，避免 Vue 2 那样的 O(n) 遍历。

**2. 遍历旧节点，进行复用或删除**
遍历**剩余的旧节点**，去上面的 Map 找有没有对应的 Key。

-   **没找到：** 说明该节点在新列表中不存在，直接**删除**（卸载 DOM）。
-   **找到了：** 说明节点复用。

    -   执行 patch（更新属性）。
    -   记录该节点在新列表中的索引位置，存入一个数组 `newIndexToOldIndexMap`。
    -   这个数组记录了**新列表中的节点在旧列表中的相对顺序**。

    > **例子：**
    > 旧：`a, b, c, d, e, f, g`
    > 新：`a, b, e, c, d, h, f, g`
    >
    > 掐头去尾后：
    > 旧剩余：`c, d, e`
    > 新剩余：`e, c, d, h`
    >
    > 经过这一步，`newIndexToOldIndexMap` (代表新剩余节点在旧列表的索引) 可能是：`[4, 2, 3, 0]` (0 表示是新增节点 h)。
    > _注：实际源码中索引会+1 以避免 0 的歧义，这里为了好理解简化了。_

**3. 计算最长递增子序列 (LIS)**
这是 Vue 3 Diff 算法的灵魂。
现在的目标是：**如何用最少的移动次数，把乱序的节点排好？**

我们得到了一个位置数组，比如 `[4, 2, 3]`（忽略新增项）。
这就变成了一个纯算法问题：**在 `[4, 2, 3]` 中，哪些元素可以不动？**
答案是：**最长递增子序列**。

-   `[4, 2, 3]` 的最长递增子序列是 `[2, 3]`。
-   这意味着：原来在位置 2 和 3 的节点（即 c, d），它们在旧列表里是 `c -> d`，在新列表里也是 `c -> d`。
-   **结论：** `c` 和 `d` **不需要移动**！
-   节点 `e`（对应索引 4）不在子序列里，所以只需要移动 `e` 即可。

**4. 执行移动**

-   Vue 3 对比“当前的索引序列”和“计算出的 LIS”。
-   如果节点在 LIS 上，跳过（不动）。
-   如果节点不在 LIS 上，执行 `insertBefore` 将其移动到正确位置。
-   如果是新增节点（索引标记为 0），直接创建挂载。

## 一句话总结

> "Vue 3 的 Diff 算法相比 Vue 2 做了重大升级，主要是为了**减少 DOM 的移动操作**，因为 DOM 移动非常消耗性能。具体流程如下：
>
> 1.  **预处理（掐头去尾）：** 先从头和尾分别进行比对，处理掉相同的节点。这样可以快速处理简单的追加或删除操作，如果是简单场景，Diff 在这一步就结束了。
> 2.  **处理乱序（最长递增子序列）：** 当遇到中间复杂的乱序情况时：
>     -   首先，它会基于新节点生成一个 `key -> index` 的 Map，通过 O(1) 的复杂度快速判断旧节点是否被复用。
>     -   然后，它会生成一个数组，记录新节点在旧列表中的位置索引。
>     -   **关键点来了：** 算法会计算这个索引数组的 **最长递增子序列 (LIS)**。
>     -   在这个序列中的节点，代表它们的相对顺序没有变，**不需要移动**。
>     -   算法只需要移动那些**不**在这个序列中的节点。
>
> **相比 Vue 2：** Vue 2 是双端比较，虽然也能处理，但在复杂乱序下无法保证移动次数最少。Vue 3 利用 LIS 算法保证了 DOM 移动操作是最小化的。"

**加分项：**

问“最长递增子序列是怎么算的”，你可以简单提一下：Vue 3 内部使用的是**贪心算法 + 二分查找**，时间复杂度是 `O(n log n)`。

## 简单描述 LIS

定义：

在一个杂乱的数字序列中，找出一组数字，它们满足两个条件：

递增： 也就是从小到大排列。

顺序不变： 在原序列里的相对前后位置不能变（可以跳着选，不用挨着）。

最长： 这样的组合可能有很多，我们要找最长的那一组。

[ 5, 3, 4, 9, 2, 8 ] 中最长子序列就是[3,4,9]
